// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'list_sof_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ListSofInitiated {
  int get page => throw _privateConstructorUsedError;
  int get limit => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ListSofInitiatedCopyWith<ListSofInitiated> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListSofInitiatedCopyWith<$Res> {
  factory $ListSofInitiatedCopyWith(
          ListSofInitiated value, $Res Function(ListSofInitiated) then) =
      _$ListSofInitiatedCopyWithImpl<$Res, ListSofInitiated>;
  @useResult
  $Res call({int page, int limit});
}

/// @nodoc
class _$ListSofInitiatedCopyWithImpl<$Res, $Val extends ListSofInitiated>
    implements $ListSofInitiatedCopyWith<$Res> {
  _$ListSofInitiatedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? page = null,
    Object? limit = null,
  }) {
    return _then(_value.copyWith(
      page: null == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
      limit: null == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListSofInitiatedImplCopyWith<$Res>
    implements $ListSofInitiatedCopyWith<$Res> {
  factory _$$ListSofInitiatedImplCopyWith(_$ListSofInitiatedImpl value,
          $Res Function(_$ListSofInitiatedImpl) then) =
      __$$ListSofInitiatedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int page, int limit});
}

/// @nodoc
class __$$ListSofInitiatedImplCopyWithImpl<$Res>
    extends _$ListSofInitiatedCopyWithImpl<$Res, _$ListSofInitiatedImpl>
    implements _$$ListSofInitiatedImplCopyWith<$Res> {
  __$$ListSofInitiatedImplCopyWithImpl(_$ListSofInitiatedImpl _value,
      $Res Function(_$ListSofInitiatedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? page = null,
    Object? limit = null,
  }) {
    return _then(_$ListSofInitiatedImpl(
      page: null == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
      limit: null == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ListSofInitiatedImpl
    with DiagnosticableTreeMixin
    implements _ListSofInitiated {
  const _$ListSofInitiatedImpl({required this.page, required this.limit});

  @override
  final int page;
  @override
  final int limit;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ListSofInitiated(page: $page, limit: $limit)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ListSofInitiated'))
      ..add(DiagnosticsProperty('page', page))
      ..add(DiagnosticsProperty('limit', limit));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListSofInitiatedImpl &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.limit, limit) || other.limit == limit));
  }

  @override
  int get hashCode => Object.hash(runtimeType, page, limit);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListSofInitiatedImplCopyWith<_$ListSofInitiatedImpl> get copyWith =>
      __$$ListSofInitiatedImplCopyWithImpl<_$ListSofInitiatedImpl>(
          this, _$identity);
}

abstract class _ListSofInitiated implements ListSofInitiated {
  const factory _ListSofInitiated(
      {required final int page,
      required final int limit}) = _$ListSofInitiatedImpl;

  @override
  int get page;
  @override
  int get limit;
  @override
  @JsonKey(ignore: true)
  _$$ListSofInitiatedImplCopyWith<_$ListSofInitiatedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UserItemBookmarked {
  int get idUserItem => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UserItemBookmarkedCopyWith<UserItemBookmarked> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserItemBookmarkedCopyWith<$Res> {
  factory $UserItemBookmarkedCopyWith(
          UserItemBookmarked value, $Res Function(UserItemBookmarked) then) =
      _$UserItemBookmarkedCopyWithImpl<$Res, UserItemBookmarked>;
  @useResult
  $Res call({int idUserItem});
}

/// @nodoc
class _$UserItemBookmarkedCopyWithImpl<$Res, $Val extends UserItemBookmarked>
    implements $UserItemBookmarkedCopyWith<$Res> {
  _$UserItemBookmarkedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? idUserItem = null,
  }) {
    return _then(_value.copyWith(
      idUserItem: null == idUserItem
          ? _value.idUserItem
          : idUserItem // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UserItemBookmarkedImplCopyWith<$Res>
    implements $UserItemBookmarkedCopyWith<$Res> {
  factory _$$UserItemBookmarkedImplCopyWith(_$UserItemBookmarkedImpl value,
          $Res Function(_$UserItemBookmarkedImpl) then) =
      __$$UserItemBookmarkedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int idUserItem});
}

/// @nodoc
class __$$UserItemBookmarkedImplCopyWithImpl<$Res>
    extends _$UserItemBookmarkedCopyWithImpl<$Res, _$UserItemBookmarkedImpl>
    implements _$$UserItemBookmarkedImplCopyWith<$Res> {
  __$$UserItemBookmarkedImplCopyWithImpl(_$UserItemBookmarkedImpl _value,
      $Res Function(_$UserItemBookmarkedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? idUserItem = null,
  }) {
    return _then(_$UserItemBookmarkedImpl(
      idUserItem: null == idUserItem
          ? _value.idUserItem
          : idUserItem // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$UserItemBookmarkedImpl
    with DiagnosticableTreeMixin
    implements _UserItemBookmarked {
  const _$UserItemBookmarkedImpl({required this.idUserItem});

  @override
  final int idUserItem;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'UserItemBookmarked(idUserItem: $idUserItem)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'UserItemBookmarked'))
      ..add(DiagnosticsProperty('idUserItem', idUserItem));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserItemBookmarkedImpl &&
            (identical(other.idUserItem, idUserItem) ||
                other.idUserItem == idUserItem));
  }

  @override
  int get hashCode => Object.hash(runtimeType, idUserItem);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserItemBookmarkedImplCopyWith<_$UserItemBookmarkedImpl> get copyWith =>
      __$$UserItemBookmarkedImplCopyWithImpl<_$UserItemBookmarkedImpl>(
          this, _$identity);
}

abstract class _UserItemBookmarked implements UserItemBookmarked {
  const factory _UserItemBookmarked({required final int idUserItem}) =
      _$UserItemBookmarkedImpl;

  @override
  int get idUserItem;
  @override
  @JsonKey(ignore: true)
  _$$UserItemBookmarkedImplCopyWith<_$UserItemBookmarkedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LoadMoreItem {}

/// @nodoc
abstract class $LoadMoreItemCopyWith<$Res> {
  factory $LoadMoreItemCopyWith(
          LoadMoreItem value, $Res Function(LoadMoreItem) then) =
      _$LoadMoreItemCopyWithImpl<$Res, LoadMoreItem>;
}

/// @nodoc
class _$LoadMoreItemCopyWithImpl<$Res, $Val extends LoadMoreItem>
    implements $LoadMoreItemCopyWith<$Res> {
  _$LoadMoreItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LoadMoreItemImplCopyWith<$Res> {
  factory _$$LoadMoreItemImplCopyWith(
          _$LoadMoreItemImpl value, $Res Function(_$LoadMoreItemImpl) then) =
      __$$LoadMoreItemImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadMoreItemImplCopyWithImpl<$Res>
    extends _$LoadMoreItemCopyWithImpl<$Res, _$LoadMoreItemImpl>
    implements _$$LoadMoreItemImplCopyWith<$Res> {
  __$$LoadMoreItemImplCopyWithImpl(
      _$LoadMoreItemImpl _value, $Res Function(_$LoadMoreItemImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadMoreItemImpl with DiagnosticableTreeMixin implements _LoadMoreItem {
  const _$LoadMoreItemImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoadMoreItem()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'LoadMoreItem'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadMoreItemImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _LoadMoreItem implements LoadMoreItem {
  const factory _LoadMoreItem() = _$LoadMoreItemImpl;
}

/// @nodoc
mixin _$FilterBookmarked {}

/// @nodoc
abstract class $FilterBookmarkedCopyWith<$Res> {
  factory $FilterBookmarkedCopyWith(
          FilterBookmarked value, $Res Function(FilterBookmarked) then) =
      _$FilterBookmarkedCopyWithImpl<$Res, FilterBookmarked>;
}

/// @nodoc
class _$FilterBookmarkedCopyWithImpl<$Res, $Val extends FilterBookmarked>
    implements $FilterBookmarkedCopyWith<$Res> {
  _$FilterBookmarkedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FilterBookmarkedImplCopyWith<$Res> {
  factory _$$FilterBookmarkedImplCopyWith(_$FilterBookmarkedImpl value,
          $Res Function(_$FilterBookmarkedImpl) then) =
      __$$FilterBookmarkedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FilterBookmarkedImplCopyWithImpl<$Res>
    extends _$FilterBookmarkedCopyWithImpl<$Res, _$FilterBookmarkedImpl>
    implements _$$FilterBookmarkedImplCopyWith<$Res> {
  __$$FilterBookmarkedImplCopyWithImpl(_$FilterBookmarkedImpl _value,
      $Res Function(_$FilterBookmarkedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FilterBookmarkedImpl
    with DiagnosticableTreeMixin
    implements _FilterBookmarked {
  const _$FilterBookmarkedImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FilterBookmarked()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'FilterBookmarked'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FilterBookmarkedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _FilterBookmarked implements FilterBookmarked {
  const factory _FilterBookmarked() = _$FilterBookmarkedImpl;
}

/// @nodoc
mixin _$UserItemCardPressed {
  UserItem get user => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UserItemCardPressedCopyWith<UserItemCardPressed> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserItemCardPressedCopyWith<$Res> {
  factory $UserItemCardPressedCopyWith(
          UserItemCardPressed value, $Res Function(UserItemCardPressed) then) =
      _$UserItemCardPressedCopyWithImpl<$Res, UserItemCardPressed>;
  @useResult
  $Res call({UserItem user});

  $UserItemCopyWith<$Res> get user;
}

/// @nodoc
class _$UserItemCardPressedCopyWithImpl<$Res, $Val extends UserItemCardPressed>
    implements $UserItemCardPressedCopyWith<$Res> {
  _$UserItemCardPressedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? user = null,
  }) {
    return _then(_value.copyWith(
      user: null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserItem,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UserItemCopyWith<$Res> get user {
    return $UserItemCopyWith<$Res>(_value.user, (value) {
      return _then(_value.copyWith(user: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$UserItemCardPressedImplCopyWith<$Res>
    implements $UserItemCardPressedCopyWith<$Res> {
  factory _$$UserItemCardPressedImplCopyWith(_$UserItemCardPressedImpl value,
          $Res Function(_$UserItemCardPressedImpl) then) =
      __$$UserItemCardPressedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({UserItem user});

  @override
  $UserItemCopyWith<$Res> get user;
}

/// @nodoc
class __$$UserItemCardPressedImplCopyWithImpl<$Res>
    extends _$UserItemCardPressedCopyWithImpl<$Res, _$UserItemCardPressedImpl>
    implements _$$UserItemCardPressedImplCopyWith<$Res> {
  __$$UserItemCardPressedImplCopyWithImpl(_$UserItemCardPressedImpl _value,
      $Res Function(_$UserItemCardPressedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? user = null,
  }) {
    return _then(_$UserItemCardPressedImpl(
      user: null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserItem,
    ));
  }
}

/// @nodoc

class _$UserItemCardPressedImpl
    with DiagnosticableTreeMixin
    implements _UserItemCardPressed {
  const _$UserItemCardPressedImpl({required this.user});

  @override
  final UserItem user;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'UserItemCardPressed(user: $user)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'UserItemCardPressed'))
      ..add(DiagnosticsProperty('user', user));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserItemCardPressedImpl &&
            (identical(other.user, user) || other.user == user));
  }

  @override
  int get hashCode => Object.hash(runtimeType, user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserItemCardPressedImplCopyWith<_$UserItemCardPressedImpl> get copyWith =>
      __$$UserItemCardPressedImplCopyWithImpl<_$UserItemCardPressedImpl>(
          this, _$identity);
}

abstract class _UserItemCardPressed implements UserItemCardPressed {
  const factory _UserItemCardPressed({required final UserItem user}) =
      _$UserItemCardPressedImpl;

  @override
  UserItem get user;
  @override
  @JsonKey(ignore: true)
  _$$UserItemCardPressedImplCopyWith<_$UserItemCardPressedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ListSofState {
  int get pageNumber => throw _privateConstructorUsedError;
  bool get isFilter => throw _privateConstructorUsedError;
  UsersResponse get userResponse => throw _privateConstructorUsedError;
  List<UserItem> get userItems => throw _privateConstructorUsedError;
  List<UserItem> get userItemsFilter => throw _privateConstructorUsedError;
  List<UserItem> get userItemsPreLoading => throw _privateConstructorUsedError;
  Map<int, bool> get userBookmarked => throw _privateConstructorUsedError;
  List<int> get userBookmarkeds => throw _privateConstructorUsedError;
  int get pageLimit => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ListSofStateCopyWith<ListSofState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListSofStateCopyWith<$Res> {
  factory $ListSofStateCopyWith(
          ListSofState value, $Res Function(ListSofState) then) =
      _$ListSofStateCopyWithImpl<$Res, ListSofState>;
  @useResult
  $Res call(
      {int pageNumber,
      bool isFilter,
      UsersResponse userResponse,
      List<UserItem> userItems,
      List<UserItem> userItemsFilter,
      List<UserItem> userItemsPreLoading,
      Map<int, bool> userBookmarked,
      List<int> userBookmarkeds,
      int pageLimit});

  $UsersResponseCopyWith<$Res> get userResponse;
}

/// @nodoc
class _$ListSofStateCopyWithImpl<$Res, $Val extends ListSofState>
    implements $ListSofStateCopyWith<$Res> {
  _$ListSofStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pageNumber = null,
    Object? isFilter = null,
    Object? userResponse = null,
    Object? userItems = null,
    Object? userItemsFilter = null,
    Object? userItemsPreLoading = null,
    Object? userBookmarked = null,
    Object? userBookmarkeds = null,
    Object? pageLimit = null,
  }) {
    return _then(_value.copyWith(
      pageNumber: null == pageNumber
          ? _value.pageNumber
          : pageNumber // ignore: cast_nullable_to_non_nullable
              as int,
      isFilter: null == isFilter
          ? _value.isFilter
          : isFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      userResponse: null == userResponse
          ? _value.userResponse
          : userResponse // ignore: cast_nullable_to_non_nullable
              as UsersResponse,
      userItems: null == userItems
          ? _value.userItems
          : userItems // ignore: cast_nullable_to_non_nullable
              as List<UserItem>,
      userItemsFilter: null == userItemsFilter
          ? _value.userItemsFilter
          : userItemsFilter // ignore: cast_nullable_to_non_nullable
              as List<UserItem>,
      userItemsPreLoading: null == userItemsPreLoading
          ? _value.userItemsPreLoading
          : userItemsPreLoading // ignore: cast_nullable_to_non_nullable
              as List<UserItem>,
      userBookmarked: null == userBookmarked
          ? _value.userBookmarked
          : userBookmarked // ignore: cast_nullable_to_non_nullable
              as Map<int, bool>,
      userBookmarkeds: null == userBookmarkeds
          ? _value.userBookmarkeds
          : userBookmarkeds // ignore: cast_nullable_to_non_nullable
              as List<int>,
      pageLimit: null == pageLimit
          ? _value.pageLimit
          : pageLimit // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UsersResponseCopyWith<$Res> get userResponse {
    return $UsersResponseCopyWith<$Res>(_value.userResponse, (value) {
      return _then(_value.copyWith(userResponse: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ListSofStateImplCopyWith<$Res>
    implements $ListSofStateCopyWith<$Res> {
  factory _$$ListSofStateImplCopyWith(
          _$ListSofStateImpl value, $Res Function(_$ListSofStateImpl) then) =
      __$$ListSofStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int pageNumber,
      bool isFilter,
      UsersResponse userResponse,
      List<UserItem> userItems,
      List<UserItem> userItemsFilter,
      List<UserItem> userItemsPreLoading,
      Map<int, bool> userBookmarked,
      List<int> userBookmarkeds,
      int pageLimit});

  @override
  $UsersResponseCopyWith<$Res> get userResponse;
}

/// @nodoc
class __$$ListSofStateImplCopyWithImpl<$Res>
    extends _$ListSofStateCopyWithImpl<$Res, _$ListSofStateImpl>
    implements _$$ListSofStateImplCopyWith<$Res> {
  __$$ListSofStateImplCopyWithImpl(
      _$ListSofStateImpl _value, $Res Function(_$ListSofStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pageNumber = null,
    Object? isFilter = null,
    Object? userResponse = null,
    Object? userItems = null,
    Object? userItemsFilter = null,
    Object? userItemsPreLoading = null,
    Object? userBookmarked = null,
    Object? userBookmarkeds = null,
    Object? pageLimit = null,
  }) {
    return _then(_$ListSofStateImpl(
      pageNumber: null == pageNumber
          ? _value.pageNumber
          : pageNumber // ignore: cast_nullable_to_non_nullable
              as int,
      isFilter: null == isFilter
          ? _value.isFilter
          : isFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      userResponse: null == userResponse
          ? _value.userResponse
          : userResponse // ignore: cast_nullable_to_non_nullable
              as UsersResponse,
      userItems: null == userItems
          ? _value._userItems
          : userItems // ignore: cast_nullable_to_non_nullable
              as List<UserItem>,
      userItemsFilter: null == userItemsFilter
          ? _value._userItemsFilter
          : userItemsFilter // ignore: cast_nullable_to_non_nullable
              as List<UserItem>,
      userItemsPreLoading: null == userItemsPreLoading
          ? _value._userItemsPreLoading
          : userItemsPreLoading // ignore: cast_nullable_to_non_nullable
              as List<UserItem>,
      userBookmarked: null == userBookmarked
          ? _value._userBookmarked
          : userBookmarked // ignore: cast_nullable_to_non_nullable
              as Map<int, bool>,
      userBookmarkeds: null == userBookmarkeds
          ? _value._userBookmarkeds
          : userBookmarkeds // ignore: cast_nullable_to_non_nullable
              as List<int>,
      pageLimit: null == pageLimit
          ? _value.pageLimit
          : pageLimit // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ListSofStateImpl with DiagnosticableTreeMixin implements _ListSofState {
  const _$ListSofStateImpl(
      {this.pageNumber = 0,
      this.isFilter = false,
      this.userResponse = const UsersResponse(),
      final List<UserItem> userItems = const [],
      final List<UserItem> userItemsFilter = const [],
      final List<UserItem> userItemsPreLoading = const [],
      final Map<int, bool> userBookmarked = const {},
      final List<int> userBookmarkeds = const [],
      this.pageLimit = 0})
      : _userItems = userItems,
        _userItemsFilter = userItemsFilter,
        _userItemsPreLoading = userItemsPreLoading,
        _userBookmarked = userBookmarked,
        _userBookmarkeds = userBookmarkeds;

  @override
  @JsonKey()
  final int pageNumber;
  @override
  @JsonKey()
  final bool isFilter;
  @override
  @JsonKey()
  final UsersResponse userResponse;
  final List<UserItem> _userItems;
  @override
  @JsonKey()
  List<UserItem> get userItems {
    if (_userItems is EqualUnmodifiableListView) return _userItems;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_userItems);
  }

  final List<UserItem> _userItemsFilter;
  @override
  @JsonKey()
  List<UserItem> get userItemsFilter {
    if (_userItemsFilter is EqualUnmodifiableListView) return _userItemsFilter;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_userItemsFilter);
  }

  final List<UserItem> _userItemsPreLoading;
  @override
  @JsonKey()
  List<UserItem> get userItemsPreLoading {
    if (_userItemsPreLoading is EqualUnmodifiableListView)
      return _userItemsPreLoading;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_userItemsPreLoading);
  }

  final Map<int, bool> _userBookmarked;
  @override
  @JsonKey()
  Map<int, bool> get userBookmarked {
    if (_userBookmarked is EqualUnmodifiableMapView) return _userBookmarked;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_userBookmarked);
  }

  final List<int> _userBookmarkeds;
  @override
  @JsonKey()
  List<int> get userBookmarkeds {
    if (_userBookmarkeds is EqualUnmodifiableListView) return _userBookmarkeds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_userBookmarkeds);
  }

  @override
  @JsonKey()
  final int pageLimit;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ListSofState(pageNumber: $pageNumber, isFilter: $isFilter, userResponse: $userResponse, userItems: $userItems, userItemsFilter: $userItemsFilter, userItemsPreLoading: $userItemsPreLoading, userBookmarked: $userBookmarked, userBookmarkeds: $userBookmarkeds, pageLimit: $pageLimit)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ListSofState'))
      ..add(DiagnosticsProperty('pageNumber', pageNumber))
      ..add(DiagnosticsProperty('isFilter', isFilter))
      ..add(DiagnosticsProperty('userResponse', userResponse))
      ..add(DiagnosticsProperty('userItems', userItems))
      ..add(DiagnosticsProperty('userItemsFilter', userItemsFilter))
      ..add(DiagnosticsProperty('userItemsPreLoading', userItemsPreLoading))
      ..add(DiagnosticsProperty('userBookmarked', userBookmarked))
      ..add(DiagnosticsProperty('userBookmarkeds', userBookmarkeds))
      ..add(DiagnosticsProperty('pageLimit', pageLimit));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListSofStateImpl &&
            (identical(other.pageNumber, pageNumber) ||
                other.pageNumber == pageNumber) &&
            (identical(other.isFilter, isFilter) ||
                other.isFilter == isFilter) &&
            (identical(other.userResponse, userResponse) ||
                other.userResponse == userResponse) &&
            const DeepCollectionEquality()
                .equals(other._userItems, _userItems) &&
            const DeepCollectionEquality()
                .equals(other._userItemsFilter, _userItemsFilter) &&
            const DeepCollectionEquality()
                .equals(other._userItemsPreLoading, _userItemsPreLoading) &&
            const DeepCollectionEquality()
                .equals(other._userBookmarked, _userBookmarked) &&
            const DeepCollectionEquality()
                .equals(other._userBookmarkeds, _userBookmarkeds) &&
            (identical(other.pageLimit, pageLimit) ||
                other.pageLimit == pageLimit));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      pageNumber,
      isFilter,
      userResponse,
      const DeepCollectionEquality().hash(_userItems),
      const DeepCollectionEquality().hash(_userItemsFilter),
      const DeepCollectionEquality().hash(_userItemsPreLoading),
      const DeepCollectionEquality().hash(_userBookmarked),
      const DeepCollectionEquality().hash(_userBookmarkeds),
      pageLimit);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListSofStateImplCopyWith<_$ListSofStateImpl> get copyWith =>
      __$$ListSofStateImplCopyWithImpl<_$ListSofStateImpl>(this, _$identity);
}

abstract class _ListSofState implements ListSofState {
  const factory _ListSofState(
      {final int pageNumber,
      final bool isFilter,
      final UsersResponse userResponse,
      final List<UserItem> userItems,
      final List<UserItem> userItemsFilter,
      final List<UserItem> userItemsPreLoading,
      final Map<int, bool> userBookmarked,
      final List<int> userBookmarkeds,
      final int pageLimit}) = _$ListSofStateImpl;

  @override
  int get pageNumber;
  @override
  bool get isFilter;
  @override
  UsersResponse get userResponse;
  @override
  List<UserItem> get userItems;
  @override
  List<UserItem> get userItemsFilter;
  @override
  List<UserItem> get userItemsPreLoading;
  @override
  Map<int, bool> get userBookmarked;
  @override
  List<int> get userBookmarkeds;
  @override
  int get pageLimit;
  @override
  @JsonKey(ignore: true)
  _$$ListSofStateImplCopyWith<_$ListSofStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
